SETTINGS
    add a method isFantom (default return is False)

GLOBAL SETTINGS

    DATA STRUCT
        a set of loader information
            only in global settings
            
            each loader know where are its value
                see belows

        a simple list of value
    
    ALGO
        if an update occur on a parameter in the execution of an addon, the origin is the addon
        if this kind of update occur in the parameter addon, the origin is system
        add method isFantom, return true if no loader in list

PARAMETER MANAGER
    manage fantom parameter, shouldn't be available, except with a "force argument"

PARAMETER LOADER

    DATA STRUCT
        list of value to add (come from registering)
        hash of values loaded = hash(value coming from registering + extra value - value to remove)
        hash of the file, or None if does not exist

    ALGO
        remove overwritte in registering and manage conflict
    
        On addon load
            compute value to load in parameter : value coming from registering + extra value (conf file) - value to remove (conf file)
            compute hash of the value to add
            compute file hash
            create parameter if needed, then load value inside of it

        On addon unload
            action on each parameter
                remove every value attached to this loader
                remove loader
                if no more loader in the list, remove parameter
            
            action on config file
                compute extra value list, value in parameter but no in "value to add"
                compute removed value list, value in "value to add" but not in parameter
                compute if we need to save
                
                in system, save settings and also fantom parameter

EXECUTER
    At exit, every addon are unloaded

ADDON ADDON
    update these method and add "origin" (an existing and loaded loader, default is system)
        parameter set
        parameter unset
        parameter add value
        parameter remove value



###############################################


LIST OF LOADER, procedure type
    goal: know where are the command for a specific loader
    axioms: command could be totally merged in random place in the procedure

    SOLUTION 1: map of loader + a loader know its procedures + a procedure know its loader

        add command at index: O(1)
        remove command at index: O(1)
        unload loader: O(n) with n the total of command for the whole procedure

        need a way to easily/quickly know the index of the command
        a procedure should know its index

    SOLUTION 2: the list of procedure is for internal usage, no getValue to return value
        a kind of linked list with pre/next could be implemented
        yeah but what about the GOTO mechanism
            three link prev/true/false
                ref or index
            false can be None
            true is None in case of last item
            in case of removing, link prev and true

            how to do if we want to add a goto ? or retrieve a specific index ?
                put every tuple in an indexed list, so index accessible
                    again we have the problem of knowing the index to access in case of remove
                    need to propagate new index in case of removal

    SOLUTION 3 XXX : double double linked list XXX
        1) a first linked list in the procedure execution (prev/true/false)
        2) a second linked list in loader (prev/next)
            a loader hold a ref to its first item
            the first item has a ref to its loader (maybe every items has a ref to their loader (?)(if needed))
        3) each object has a static key and know it
            find a way to compute static key, simple to use
        4) each object is registered in a map with its static key
        5) loader in a map

        every op become o(1): win
            maybe a bit of memory waste

        key generation:
            solution 1: juste keep a counter and give the next available to the next command
                the key is only valid at runtime


LIST OF LOADER, parameter type
    goal: know where are the value
    
    axioms: 
        every values of the same loader are grouped (not necessary)
        the output of getValue has to be a python list
            do not want to build the list on getValue

    BRAINSTORMING
        items are into a python list
        they can be grouped by loader or not

    possible operation: 
        addValue: occur during creation and execution
        removeValue: at the execution
        getLoaderValue: at the destruction

    list or orderedDic or dic for loader ?
        orderedDic is better because at each operation, need to retrieve index for a specific loader
        with a list we should iterate on every available item to retrieve the correct loader

    SOLUTION 1: orderedDic + items grouped by loader + tuple(first index, size, loader ref (?) )
        every complexity are O(n)
            worst case if every loader only hold one value and update the first loader
        need to update every loader after in the list

    SOLUTION 2: orderedDic +items grouped by loader + tuple(size)
        to retrieve index, need to add every size
        need to iter on every loader before in the list
        previous solution is a little bit better

    SOLUTION 3: each value store an information about its loader and a counter
        a remove, reduce the counter : o(1)
        an add, increase the counter : o(1)
        getValue, need to iterate over every value to retrieve the first one: o(n)

        and the getValue of this parameter return every information of tagging...

        question: is it possible to colorate a base type ? setattr does not work :/

    SOLUTION 4: orderedDic + items not grouped by loader + list of index (ordered)
        add an items: o(1)
        remove an item: o(n), need to update every upper index in the index list
        unload loader: o(m) with the items associated to the loader


    SOLUTION 5: reconstruct the list for getValue on any add/remove
        O(n) at each operation

    SOLUTION 6: override list interface XXX
        a list composed of several sub list
            map of list (key is the loader id)
        each sub list is associated to a loader
        a compute index method, compute the sub list index and the index in the sublist

        remove: O(1)
        add: O(1), by default, add on system loader list
        getFromLoader: O(1)

        getSlice and other kind of method: O(n)

        --- will be funny to implement :)
        --- not really convince by this solution

    SOLUTION 7: a tree ?
        nop, must be indexable

    SOLUTION 8: wrap the value
        a value is wrapped into a container that hold the value
        map of loader to their first container (also keep the size)
        linked list of item

        still the sme prblm of index update...

    SOLUTION 9: TODO



PRBLM what about context list of value, it hold a set, not a list of value...
    what to do if two loader want to add the same value ?

    update process to compute value removed

    what about value added ?

    SOLUTION 1: 
        On load, if value exists, do not add, but if value does not exist, add it
        On unload, if value is not in the set anymore, mark as removed in every loader
        On unload, if value still exists, only remove the value if no other loader are interested by the value

        PRBLM 1: what about value adding to a specific loader ?
            only one instance of value can exist at a time
            if the value has been removed and marked as removed in several loader, how to add it again ?

            SOLUTION 1: allowed to set several origin in value add XXX
                or even a special keyword "*" to add in every loaded loader

        PRBLM 2: How to know which value is registered to which loader ?
            SOLUTION 1: each value hold a counter of interested loader (could be a simple map) XXX
            SOLUTION 2: each value is attached to a list of loader
                not really useful to get the list of loader
            SOLUTION 3: could use the list of value to remove
                this list does not exist anymore...

        PRBLM 3: about value tracking ? value are merged every where...
            a loader has to known which are its values
            ideally, don't just keep a list of index...
            linked to the problem of parameter tracking value
            value index never change, except if a remove occurs on a previous value

            SOLUTION 1: list of index
                --- need to update index of every loader on every removal

            SOLUTION 2: list of value
                --- each value is stored at lead two time and maybe more...

            SOLUTION 3: double map
                a map A with
                    key = loader
                    value = set of loader value

                a map B with
                    key = loader value
                    value = list of loader

                getValue return B.keys()
                add/remove o(1)
                load/unload o(n) with n the list of value in the loader to load/unload
                memory: o(n2)

            SOLUTION 4: TODO


PRBLM how to restore command moving after an application reboot ?
    e.g. two commands are reversed in the list

    command can come from registering, added by user or added in a process
    a command could disappear
    a command is not identified with a uniq id out of running (hash ?)

    what about command merge with different loader origin ?

    SOLUTION 1:
        registering order can not be modifier (on run time ? or only on reboot ?)
        order is saved in front of the command of the same loader origin only
            if two command from different loader are merger, this is not saved
        other command are saved in line and in the correct order during the save process

        --- registered command can not be inverted or suppressed

    SOLUTION 2: XXX
        command from registering are not supposed to change
        move the command in front of their supposed key

PRBLM what about removing a command from registering ?
    
    SOLUTION 1: add a boolean to enable/disable command
        command from registering are not removable but it is possible to disable them

PRBLM what about goto in file procedure ? TODO
    if instruction are processed one after the other, a goto to a key or even an index won't be possible...


