#############################
### Bash like             ###
#############################  
shif, set, loop, if, goto, ...

#############################
### keystore              ###
#############################    
    be able to cypher it

#############################
### utilisation des tries ###
#############################

plusieurs mechanisme n'utilise pas les tries dans leur fonctionnement, c'est un peu dommage et ça casse la synergie
    
    Where to update:
        -Parameter parent name
        -Parameter name
        -var name (avant de résoudre ici, voir si les var ne vont pas disparaitre et etre remplacée par des generic parameter)
        -addon name
        -...

    look after dictionary init { everywhere in the code

##################
### argchecker ###
##################

-string
    min size

################
### executer ###
################
    #manage sigint, sigkill, ...
        #interrompre l'ensemble des process en cours
        #ou flinguer le courant et demander pour la suite
            #comme dans un terminal classique
    
#################
### stdaddons ###
#################      
    #gérer les commentaires
        #voir shell.py

#################################
### parameter in command call ###
#################################

    ??? Executeur ou ArgChecherS ? entre les deux ?
    -permettre a l'utilisateur de binder uniquement certains argument
        exemple:
            cmd(a,b,c=None,d=None,e=None)
            
        cmd ValueA ValueB -e ValueE
        
        attention aux nombres négatif -5, -42.23, ...
        attention au cas ou on a un arg en dernier de liste
        attention au cas ou on a deux (ou plusieurs) param qui se suivent -a -c -d

        PRBLM on a un risque de perte d'information si on utilise le - comme marqueur de parametre
            si on melange les argument avec parametre et ceux sans
            example : cmd toto(<string> ... <string>2) tata:<string>
                toto -tata d a b c 
                    -tata is a part of the list or the last argument ?
            
            def "nom de param" :
                - commence par un tiret
                - est directement suivi (donc pas d'espace) par le prefix du nom d'un argument existant
                - est suivi par au moins un non "non de param" (ne repondant pas aux deux criteres precedents)
                    exception pour le boolean, la presence sans valeur implique "True"
            
            SOLUTION 1
                le tiret est un caractere reservé
                on peut l'escaper en faisant \-
                    et si on veut recuperer \-, on devra encoder \\-, etc.
                    
            SOLUTION 2
                les arguments parametré le sont uniquement a la fin
                on commence a parser à partir de la fin jusqu'a ne plus trouver d'arg parametre
                et on recommence a parser a partir du debut les args manquant
                
            SOLUTION 3 <===
                a) on identifie tous les params existant
                    faire une liste des indices
                b) on place les params erronés dans une liste (pour gestion en cas d'erreur)
                c) on inteprète tous les params identifié
                d) si pas d'erreur, on interprete tout ce qui reste avec l'ancienne methode
                    les params erronés sont utilisables dans la liste comme un token normale
                
                englobe la solution 1 et 2
                PROBLEM si on essaye de binder une liste avec liste infinie, ou avec une taille min inferieur a la max, et justement on transfere le min
                    et qu'il y a encore des arguments après
                    
                    SOLUTION 1
                        on s'arrete au prochain param token identifié
                            et s'il n'y en a pas ? jusqu'au bout du flux ou de la limite

                    SOLUTION 2 
                        on defini une taille après le param genre -toto:5
                            ça demande d'ajouter une info en + alors...
                                c'est chiant

    !!!! ne devrait rien changer au decorateur, ArgChecker et argFeeder !!!
        ils fournissent juste un outils de verification de l'argument, des valeurs par defaut et des noms
        le argFeeder se charge juste de faire le binding, les valeurs paramètrées doivent être retirée avant, on fait une couche suplémentaire par dessus
            devra se trouver juste après la recherche de commande
            et juste avant le argfeeder

    #inclure la gestion des argument dynamique de type var au moment de la modif
    
    PRBLM to solve
        where to use binded argument ?
            in pre, in pro or in post ?
            
            in first real entering point, where come from the usage information
                
#####################
### print service ###
#####################

	#an interface with a few meth
		info
		    le print classic
		error
		    faire un print specific qui va ecrire dans le flux d'erreur
		    voir exemple sur internet
		warn
		    #TODO trouver une astuce
		...
		
	    L'affichage "info" peut se faire à trois endroit:
	        -simpleprocess
	        -addons
	        -executer
	        
        L'affichage "warning" et "error" peut se faire à un seul endroit:
            -executer
            
            car ce sont les exceptions qui transporte la sévérité du message
            et elle remonte jusqu'à l'executer
		
		#utiliser le package log
		
    #gérer des trucs comme >, >>, 2>, 2>>, ...
        #changer le flux d'output pour la commande
        #le restaurer ensuiste
        #s'il y a deja un descripteur de fichier ouvert vers un fichier, le reutiliser
            #pour eviter d'avoir plusieurs descripteur vers le même fichier
            #et ainsi eviter d'avoir des overlaps dans le fichier

    #commande pour rediriger l'output vers un fichier
        #faire une commande de flush
        #flush and close at exit
        #si on fait un close, il faut retirer l'event at_exit

    PRBLM
        multithreading
        shell/script/thread concurrent
        affichage unique
        
        conflict avec readline
            besoin de bricoler pour afficher des event asynchrones
            
        conflict avec l'autocompletion
            l'output d'origine doit être rétabli sinon l'autocomplet ne fonctionne pas
            ça pourrait être interessant de comprendre pourquoi ça merde
                faire une question sur stackoverflow
        
    SOLUTION 1
        faire un manager d'affichage qui prend la place du default output
            il possede:
                une reference vers l'ancien affichage
                l'id du main thread
                un lock 
                
            lorsqu'un write survient
                si script OU daemon
                    utilise print
                
                si shell
                    on verouille le lock            
                            
                    si thread principale
                        utilise le print principale
                    
                    si thread secondaire
                        utilise REPL
                    
                    unlock        
                    
            lorsqu'un autocomplete survient
                on lock
                restauration de l'ancien output
                execution de l'autocomplete
                restauration du manager d'output
                unlock
        
        ça resoud définitivement le problème de l'affichage d'info dans le multiprocess

############
### rfid ###
############

    #adapter l'ensemble du code existant au nouveau shell
        #in progress

    #/System/Library/Frameworks/PCSC.framework/Versions/A/Headers/winscard.h
        le wrapper essaye de mapper une fonction qui n'existe pas dans la lib en C, on ne peut pas faire grand chose
            afficher un message pour dire que c'est normal
            oui mais le message d'erreur ne s'affiche pas toujours, comment savoir s'il s'est affiché ou non ?
   
    #faire un système de gestion des codes d'erreurs
	    à faire dans executeAPDU
	    -pouvoir ajouter son propre handler d'erreur dans les modules  
	    
	    #!!!! ça existe dans pyscard, reutilisez
	    
    #creer de nouveau event: oncardconnect, oncarddisconnect, onreaderconnect, onreaderdisconnect, ...
        #quand le systeme multi event sera implémenté
    
    #la commande wait est pourrie dans pyscard, ça fait friser le raspi
        #essayer de voir s'il n'y a pas moyen d'en faire une custom moins agressive

    #faire des tests de multi process
        #lancer deux instances de l'application et essayer de se connecter à la même carte
            #pyscard est-il thread safe ? ou pcsc?
            
    #element faisant partie du contexte
        #type de lecteur
        #version du firmware du lecteur
        #type de carte
        #version de la carte
        #type de framew
        #...

##################################################################################################################################
##### futur work (part 1) ########################################################################################################
##################################################################################################################################

    (threading/event/thread-safe/application-safe/...)
    
    work in progress, see file EventManager and parameter

#####################
### alias manager ###
#####################

    main core element are ready
    still need to find a way to use easyly the alias editing in command line
    implementer "set" et "shift" comme dans un vrai bash
        dans le std

################################
### Parameter Thread safe    ###
################################
    
    pouvoir desactiver un lock dans un parameter ? intérêt ?
        Brainstorming todo
    
#####################
### event manager ###
#####################
    #system event
        #not removable
        #at startup, at exit, onContextChange, ...
        #could be empty

##########################################
### threading management brainstorming ###
##########################################

    #definition 
        #groupe de commande 
            #liste de 1 à n commande
        
        #process de lock
            #tous les locks sont connu
            #ils sont classé dans ordre précis
            #on les acquierent toujours dans le même ordre
            
        #lock static
            #exemple l'utilisation d'une fonction à accès unique dans une librairie
            
        #lock dynamique
            #un lecteur de carte, une carte a puce, ...

### NOT YET SOLVED ####

    #XXX    Quid des ressource dynamique necessitant un verrou d'utilisation
        #exemple une connexion vers une carte rfid
        
        #solution a la con
            #ne pas stocker de ressource devant avoir leur propre lock dans des structures ne possedant qu'un seul lock
            #dans le cas de la rfid, il suffirait de stocker les connexions et les cartes chacune dans un env indépendant
                #du coup chaque objet aurait son lock, on augmente le threading et ça résoud le problème
            
    #quid de l'execution de deux instances de l'application...
        #objet partagé avec pyro ? chiant avec pyro, besoin d'une lib externe...
        #fichier de lock ?
        #analyse des process en memoire ? (need to be root)
        #...
        
    #pour l'instant les ressource seront lockée pour un single process
        #pas pour une commande, ni une multicommande, ni une piped commande, ni un aliasevent, ni ...
        #est ce une bonne idée ?
        
    #What about parameter only accessible in a single thread ?
        a parameter object only accessible in thread environment, not in the whole app 

##################################################################################################################################
##### futur work (part 2) ########################################################################################################
##################################################################################################################################

#############################
### state machine process ### OLD NAME : workflow, application
#############################
    #d'une certaine manière, une application dans le shell
        #possede un etat (creer un objet etat qui peut stocker plein de chose)
            #le stocker dans les parametres
            #le rendre transient ou non
            
        #creer un package pour stocker les app
        #possibilité d'en importer de l'exterieur
    
    #deux types d'app:
        #simple: chaque execution d'action ramene a l'etat initiale, une sorte de simple application
            #en fait c'est une complexe sans rien de défini
        
        #complexe: une action peut conduire vers un nouvel etat dans lequel seulement certaines actions sont possibles
            #definir dans quel cas on va où, et aussi gérer les cas d'erreur
            
    #action par defaut: startApp
        #disponible lorsque l'on se trouve dans le shell au démarrage avec le tries par défaut
        #cette action va remplacer le tries courant par celui de la machine à état
        #seule les actions de la state machine sont disponibles maintenant
        
    #action par defaut: exit
        #disponible uniquement dans une application
        #toujours disponible quelque soit l'etat de l'application
        #soit renvoi dans le shell
            #et restaure l'ancien tries
            
        #soit quitte completement le shell
        
    #action par defaut: reset
        #disponible uniquement dans une application
        #toujours disponible quelque soit l'etat de l'application
        #ramene a l'etat initial si possible
        #reset l'état de l'application
        
    #comment definir une action, que se passe t'il dedans? definir les liaison ? etc.
        #pourrait être interessant d'utiliser les decorations
        #TODO


#########################
### service installer ###
#########################

    #être en mesure d'activer des applications en tant que service
        #au démarrage entre autre
    
    #need to have a loop instruction
        #or could simply use the loop instruction in shell

######################
### code generator ###
######################

    #génerer du code executable en dehors du shell
    
    #trois level de code executable:
        #level 0: un maximum de chose ont déjà été interprété (calcul d'apdu, de checksum, etc.)
            #il ne reste plus qu'à transmettre les données au framework
            #minimiser au maximum les imports en provenance du pyshell
            
        #level 1: rien n'a encore été calculé (calcul d'apdu, ...)
            #on génére le code avec les appels de fonction encore parametrable
            #implique une dépendance au code calculant les apdus
            
            créer un objet special capable de résoudre des path dans le tries, genre:
                pytries_exec.con.sel.val("debug",0).pipe(pytries_exec.echo())
                
                ça devrait être possible en overridant des methodes style getAttr, __call__, ....
            
        #level 2: rien n'est calculé, on execute via le shell
            #on est en niveau de script
            #besoin de l'ensemble du code

###########
### ... ###
###########


