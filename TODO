#############################
### keystore              ###
#############################    
    be able to cypher it

#############################
### utilisation des tries ###
#############################

plusieurs mechanisme n'utilise pas les tries dans leur fonctionnement, c'est un peu dommage et ça casse la synergie
    
    Where to update:
        -Parameter parent name
        -Parameter name
        -var name (avant de résoudre ici, voir si les var ne vont pas disparaitre et etre remplacée par des generic parameter)
        -addon name
        -...

    look after dictionary init {

##################
### decorateur ###
##################

-si un arg n'est pas binder dans un decorateur et n'a pas de valeur par defaut, le binder au simple argchecker
    s'il a un arg par defaut, normalement il prend deja cette valeur la je pense

##################
### argchecker ###
##################

-string
    min size

################
### executer ###
################
    #manage sigint, sigkill, ...
        #interrompre l'ensemble des process en cours
        #ou flinguer le courant et demander pour la suite
            #comme dans un terminal classique
    
#################
### stdaddons ###
#################      
    #gérer les commentaires
        #voir shell.py
 
    #commande de parsing de liste de byte (interpretation en int, bin, hex, ascii, ...)
        #voir dans les addons rfid
        
        #être capable de faire un diff byte sur deux sources de byte differente
            #avec des jolie couleur en mode bisounours
            #voir ansi color code
            
        #faire un addon pour ça

#################
### ALIAS     ###
#################

	#alias pointant sur 1..n commande(s)
	    append alias NAME cmd+args
	    remove alias NAME
	
        faire une liste d'alias'
            description dans le code
            
        #un alias peu être utilisé dans un autre alias
            #eviter les boucles
                #pas possible si on empêche la creation d'un alias sur une commande qui n'existe pas
        
        #probleme lors de la suppression de l'objet pointé
            #politique de suppression : on_cascade/interactive/error/nothing ?
            
        #eviter d'avoir une reference dans l'objet pointé
            #comment savoir qu'il est pointé vers un alias alors ?
            #maintenir un dic avec les mappings ?
            #checker lors de chaque suppression de commande ?
            
        #on doit être capable de stocker des args avec l'alias
            #tout en pouvant toujours lui en passer en l'appelant
        
    """def addAlias(self,CommandStrings,AliasCommandStrings):
        #pas aussi simple
            #on doit pouvoir gerer des alias avec des arguments fixe
        
        #commande speciale
            #contient le path vers la commande
            #les arguments ou une partie des arguments
        
        #TODO CommandStrings can't contain special token : >, >>, |, ...
        
        #TODO find the command in the tree
        
        #TODO build alias command
        
        #TODO insert in tree
        
        pass #TODO"""
        
    PRBLM to solve
        addon creation at once (see addon file)
        deletion politics 
        dependencies deletion politics

#################################
### parameter in command call ###
#################################

    ??? Executeur ou ArgChecherS ? entre les deux ?
    -permettre a l'utilisateur de binder uniquement certains argument
        exemple:
            cmd(a,b,c=None,d=None,e=None)
            
        cmd ValueA ValueB -e ValueE
        
        attention aux nombres négatif -5, -42.23, ...
        attention au cas ou on a un arg en dernier de liste
        attention au cas ou on a deux (ou plusieurs) param qui se suivent -a -c -d

        PRBLM on a un risque de perte d'information si on utilise le - comme marqueur de parametre
            si on melange les argument avec parametre et ceux sans
            example : cmd toto(<string> ... <string>2) tata:<string>
                toto -tata d a b c 
                    -tata is a part of the list or the last argument ?
            
            def "nom de param" :
                - commence par un tiret
                - est directement suivi (donc pas d'espace) par le prefix du nom d'un argument existant
                - est suivi par au moins un non "non de param" (ne repondant pas aux deux criteres precedents)
                    exception pour le boolean, la presence sans valeur implique "True"
            
            SOLUTION 1
                le tiret est un caractere reservé
                on peut l'escaper en faisant \-
                    et si on veut recuperer \-, on devra encoder \\-, etc.
                    
            SOLUTION 2
                les arguments parametré le sont uniquement a la fin
                on commence a parser à partir de la fin jusqu'a ne plus trouver d'arg parametre
                et on recommence a parser a partir du debut les args manquant
                
            SOLUTION 3 <===
                a) on identifie tous les params existant
                    faire une liste des indices
                b) on place les params erronés dans une liste (pour gestion en cas d'erreur)
                c) on inteprète tous les params identifié
                d) si pas d'erreur, on interprete tout ce qui reste avec l'ancienne methode
                    les params erronés sont utilisables dans la liste comme un token normale
                
                englobe la solution 1 et 2
                PROBLEM si on essaye de binder une liste avec liste infinie, ou avec une taille min inferieur a la max, et justement on transfere le min
                    et qu'il y a encore des arguments après
                    
                    SOLUTION 1
                        on s'arrete au prochain param token identifié
                            et s'il n'y en a pas ? jusqu'au bout du flux ou de la limite

                    SOLUTION 2 
                        on defini une taille après le param genre -toto:5
                            ça demande d'ajouter une info en + alors...
                                c'est chiant

    !!!! ne devrait rien changer au decorateur, ArgChecker et argFeeder !!!
        ils fournissent juste un outils de verification de l'argument, des valeurs par defaut et des noms
        le argFeeder se charge juste de faire le binding, les valeurs paramètrées doivent être retirée avant, on fait une couche suplémentaire par dessus
            devra se trouver juste après la recherche de commande
            et juste avant le argfeeder

    #inclure la gestion des argument dynamique de type var au moment de la modif
    
    PRBLM to solve
        where to use binded argument ?
            in pre, in pro or in post ?
                
#########################################################################################################################

#####################
### print service ###
#####################

	#an interface with a few meth
		info
		    le print classic
		error
		    faire un print specific qui va ecrire dans le flux d'erreur
		    voir exemple sur internet
		warn
		    #TODO trouver une astuce
		...
		
	    L'affichage "info" peut se faire à trois endroit:
	        -simpleprocess
	        -addons
	        -executer
	        
        L'affichage "warning" et "error" peut se faire à un seul endroit:
            -executer
            
            car ce sont les exceptions qui transporte la sévérité du message
            et elle remonte jusqu'à l'executer
		
		#utiliser le package log
		
    #gérer des trucs comme >, >>, 2>, 2>>, ...
        #changer le flux d'output pour la commande
        #le restaurer ensuiste
        #s'il y a deja un descripteur de fichier ouvert vers un fichier, le reutiliser
            #pour eviter d'avoir plusieurs descripteur vers le même fichier
            #et ainsi eviter d'avoir des overlaps dans le fichier

    #commande pour rediriger l'output vers un fichier
        #faire une commande de flush
        #flush and close at exit
        #si on fait un close, il faut retirer l'event at_exit

    PRBLM
        multithreading
        shell/script/thread concurrent
        affichage unique
        
        conflict avec readline
            besoin de bricoler pour afficher des event asynchrones
            
        conflict avec l'autocompletion
            l'output d'origine doit être rétabli sinon l'autocomplet ne fonctionne pas
            ça pourrait être interessant de comprendre pourquoi ça merde
                faire une question sur stackoverflow
        
    SOLUTION 1
        faire un manager d'affichage qui prend la place du default output
            il possede:
                une reference vers l'ancien affichage
                l'id du main thread
                un lock 
                
            lorsqu'un write survient
                si script OU daemon
                    utilise print
                
                si shell
                    on verouille le lock            
                            
                    si thread principale
                        utilise le print principale
                    
                    si thread secondaire
                        utilise REPL
                    
                    unlock        
                    
            lorsqu'un autocomplete survient
                on lock
                restauration de l'ancien output
                execution de l'autocomplete
                restauration du manager d'output
                unlock
        
        ça resoud définitivement le problème de l'affichage d'info dans le multiprocess

############
### rfid ###
############

    #adapter l'ensemble du code existant au nouveau shell
        #in progress

    #/System/Library/Frameworks/PCSC.framework/Versions/A/Headers/winscard.h
        le wrapper essaye de mapper une fonction qui n'existe pas dans la lib en C, on ne peut pas faire grand chose
            afficher un message pour dire que c'est normal
            oui mais le message d'erreur ne s'affiche pas toujours, comment savoir s'il s'est affiché ou non ?
   
    #faire un système de gestion des codes d'erreurs
	    à faire dans executeAPDU
	    -pouvoir ajouter son propre handler d'erreur dans les modules  
	    
	    #!!!! ça existe dans pyscard, reutilisez
	    
    #creer de nouveau event: oncardconnect, oncarddisconnect, onreaderconnect, onreaderdisconnect, ...
        #quand le systeme multi event sera implémenté
    
    #la commande wait est pourrie dans pyscard, ça fait friser le raspi
        #essayer de voir s'il n'y a pas moyen d'en faire une custom moins agressive

    #faire des tests de multi process
        #lancer deux instances de l'application et essayer de se connecter à la même carte
            #pyscard est-il thread safe ? ou pcsc?
            
    #element faisant partie du contexte
        #type de lecteur
        #version du firmware du lecteur
        #type de carte
        #version de la carte
        #type de framew
        #...

##### futur work (part 1) ########################################################################################################
    (threading/event/thread-safe/application-safe/...)

###############
### context ###
###############                
    #thread safe
        #select/get context must be thread safe
            #one lock for each contexte
            
        #see futur work

################################
### Parameter Thread safe    ###
################################

    Tout les parameter devrait pouvoir être thread safe si necessaire
        context/generic/environment/...

    Choisir a l'instanciation si thread-safe ?
    Ou les faire tous thread-safe ?

    Getvalue en thread-safe ?
    ou just le setValue ?
    
    créer un lock/unlock parameter
        pour pouvoir locker l'objet, faire un getValue, un process, ensuite un setValue et puis unlocker l'objet
        
    Systeme à double lock? un pour le get et un pour le set ?
    
    !!!! Attention, ce méchanisme entre en conflit avec la solution de multithreading deja discuté plus bas dans ce document !!!!
        risque de deadlock
        les lock doivent être réalisé au même moment
        
    utilisation des lock comme parameter ?
        créer un parameter special "lock"

#####################
### event manager ###
#####################
    #at startup
        #load param (la creation des params par defaut doit etre faites avant)
        #load history
        #load addon in param file
        
    #at exit
        #save param
        #save history
        #flush and close redirected stream
        
    #event type: onstartup, onexit, onContextChange, ...
    #add event type 
        #juste une string denomant l'event
    
    #list event name
    #list action to do on event
        #for on specific event, for an event prefix, for all event, ...
    #add action on event
        #add a string command executable in the shell
        
    #remove action on event
        #remove the action at the top
        #or remove the action at index
        
    #permettre de registerer des events dans le loader dans les addons
    #methode pour declencher les events, fire + event name
        #être capable de faire fire sur une liste d'event
        
    #ça va poser des problèmes si les events sont déclenchés dans des threads
        #car rien n'est thread safe
        
        #mettre un lock sur l'execution d'action ?
        #ou un pool de commande en attente ?
        
    #XXX prblm 1 avec l'event onContextChange
        #il va probablement survenir lors de l'execution d'un process
        #on ne peut dés lors pas executer directement l'event, on doit attendre que le courant aie fini
        #faire un pool d'execution à la fin d'une execution
        
    #XXX prblm 2 même problème que precedement mais inversé
        #si on a un event qui s'éxecute, on ne peut pas démarrer un nouveau process

###

    #XXX solution 1 pour les deux problèmes
        #faire un pool de commande thread safe à executer sequentiellement
        
        #si on tente d'executer un process manuellement et qu'un pool de commande est en cours d'execution
            #on bloque et on attend que le pool soit fini
            #si le pool de commande genere de nouvelles commandes, celles-ci seront executée avant le process manuel
            
        #si on tente d'executer une commande alors qu'un process est en cours d'execution
            #on l'ajoute dans un pool et on l'execute dès que le process manuel est fini

        #si un second thread veut ajouter des commandes
            #on fait une priority queueu, classé par thread id
            #premier arrivé, premier servi
            #chaque thread a son pool de commande
            #on ajoute les commandes dans le pool correspondant à l'id du thread qui l'a ajouté
            #le thread du prompt devient transparent vis à vis des autres threads
                #cool on gagne en genericité

        import threading
        threading.Lock()
        with self.lock:
        
        #XXX quid, on perd en puissance niveau multi processing
            #a quel point ?
    
    #XXX SOLUTION 2 chaque parameter (env/context) contient un lock
        #lors de chaque execution d'une commande ou une piped command
        #on récupere les lock de chacun des parametres utilisés
        #on lock, et on ne délock qu'après l'execution
        
        #avantage
            #permet un multithreading bien independant
            #simple a mettre en place
        
        #inconvenient
            #peut être compliqué de récupérer l'ensemble des lock
        
        #prblm to solve
            #si une routine se declenche elle meme SOLVED
                #la nouvelle routine sera dans un autre thread et devra attendre la liberation des locks
                #donc pas un prblm
                
            #quid de l'affichage et du REPL ? SOLVED pseudo code dans la partie sur l'affichage (voir plus haut)
                #si on est pas dans le thread principal, on affiche uniquement en REPL
                
                #créer une ressource REPL ? NO
                    #pas sûr que ce soit une bonne idée car pas vraiment moyen de savoir si on est dans le main thread ou non
                    #et puis ce sera seulement checké au moment de l'execution de la commande
                        #donc trop tard pour locker quelque chose correctement
                
                #au niveau de l'execution de la routine, gérer un parameter special "printable" 
                    #s'il n'est pas utilisé dans un process, pas d'affichage, pas de lock
                    #s'il est utilisé dans une methode, plusieurs cas de figure
                        #thread principale OR non
                        #shell OR daemon/script
                        
                        #si thread principale + shell => pas de lock et on utilise la methode print
                        #si thread secondaire + shell => lock + repl print
                        #si autre                     => lock + print
                        
            #pas toujours necessaire de locker l'ensemble d'un parameter NOT SOLVED
                #risque de perte de process parallele
                
                #par exemple, on a un pool de connexion et on ne veut utiliser qu'une connexion en particulier
                    #le pool est un parameter (probablement un env)
                    #on devra locker le pool pour se servir d'une seule connexion, c'est bof...
                    #par contre on doit empecher de pouvoir retirer l'element du pool donc on doit +- locker le pool aussi
                    
            #PSEUDOCODE
                variable:
                    list d'event
                        un event est une chaine de caractère unique
                        un event contient une liste de commande
                            avec ou sans argument
                        
                methode:

                    add command to event(name, command)
                        ajoute la commande à l'event s'il existe
                            si l'event n'existe pas, le créer
                            l'event name doit etre unique
                        
                    fire event(name, args)
                        lancer un nouveau thread
                            definir une variable speciale uniquement accessible dans ce thread
                                cette variable va contenir les args du thread
                                passer cette variable au commande qui le demande
                        
                            récuperer la liste de commande, faire une copie
                                cette liste ne doit pas pouvoir être modifier par un autre thread
                                
                            pour l'ensemble des commandes dans la liste
                                executer la commande (voir methode suivante)
                    
                    execute a command(command)
                        recuperer la liste des lock utilisés dans cette commande
                        les trier et les locké
                        exécuter la commande
                        libérer la commande
                        

    #plusieurs types d'event:
                    #ceux à traiter immediatement DEPRECATED
                        #dans le même thread
                        #dans un autre thread
                        
                    #ceux à traiter a la fin du process courant DEPRECATED
                        #dans le même thread
                        #dans un autre thread
                        
        #simplification CURRENT
            #un déclenchement d'event démarre directement un nouveau thread pour traiter l'event
        
        #encore d'actualité avec le thread management ?
        #même si c'est possible d'executer un process dans un process, c'est crade ...
    
    #un fireEvent doit se retrouver dans un nouveau thread pour gérer les locks (see below, threading management)
        on regroupe un liste de toute les commandes à executer
        on execute le process de lock
        on execute les commandes
        
    

##########################################
### threading management brainstorming ###
##########################################

    okay, a la base, on a juste 1 point d'input, le shell
        bien que rien n'empêche de finir une partie du process dans un tread de manière à récupérer le prompt plus rapidement
        ce traitement doit pouvoir être indèpendant de tout autre process lancer ulterieuerement
            genre: calcul de résultat, écriture sur un fichier, ...
            
    Maintenant que se passe t'il si on a des generateur externe d'evenement pouvant executer des commandes?
        ces commandes peuvent entrer en conflit d'utilisation de ressource exclusive utilisée par une commande venant du prompt
        
    Solution 1:
        tant qu'un tread n'a pas fini d'executer son pool de command, on ne permet pas à un autre tread d'executer son pool de commande
            #+ : thread safe, completement sequentiel
            #- : on perd le multitasking
            
    Solution 2: (VOIR AUSSI LA SOLUTION 2 DANS L'EVENT MANAGER)
        Chaque thread examine les ressources necessaires pour executer son groupe de commandes et essayent de les locker de manière ordonnées
        Si une ressource n'est pas libre, on attends
            #+ : thread safe aussi
            #+ : on garde le multitasking
        
        prblm si les commandes courantes generent de nouvelle commande dans un fireEvent
            #car ces nouvelles commandes ont peu être besoin de + de lock qui sont mélangé avec les locks déjà acquis
            
        #Solution 2.1:
            tout groupe de commande genéré se retrouvent dans un nouveau thread où on recommence le process de lock de zéro
    
    #definition 
        #groupe de commande 
            #liste de 1 à n commande
        
        #process de lock
            #tous les locks sont connu
            #ils sont classé dans ordre précis
            #on les acquierent toujours dans le même ordre
            
        #lock static
            #exemple l'utilisation d'une fonction à accès unique dans une librairie
            
        #lock dynamique
            #un lecteur de carte, une carte a puce, ...

    #XXX    Quid des ressource dynamique necessitant un verrou d'utilisation
        #exemple une connexion vers une carte rfid
    
            
    #quid de l'execution de deux instances de l'application...
        #objet partagé avec pyro ?
        #fichier de lock ?
        #analyse des process en memoire ? (need to be root)
        #...

##### futur work (part 2) ########################################################################################################

################
### workflow ###
################
    #n'afficher dans l'aide et n'autoriser que les commandes executables
        #de manière à vraiment guider l'utilisateur dans ce qu'il peut faire
        #toujours avoir une commande 
            #exit : pour quitter le workflow
            #reset : pour revenir au début du workflow

####################
### application  ###
####################

    #on remplace le leveltries courrant par un contenant uniquement les commandes de l'application
        #avec une commande exit pour restaurer le leveltries principale
        #les commandes du leveltries principales doivent toujours être accessible dans les commandes de l'application
        #les apps doivent pouvoir executer du code et en même temps appeler des commandes sur le shell
    
    #sorte de workflow

#########################
### service installer ###
#########################

    #être en mesure d'activer des applications en tant que service
        #au démarrage entre autre
    
    #need to have a loop instruction
        #or could simply use the loop instruction in shell

######################
### code generator ###
######################

    #génerer du code executable en dehors du shell
    
    #trois level de code executable:
        #level 0: un maximum de chose ont déjà été interprété (calcul d'apdu, de checksum, etc.)
            #il ne reste plus qu'à transmettre les données au framework
            #minimiser au maximum les imports en provenance du pyshell
            
        #level 1: rien n'a encore été calculé (calcul d'apdu, ...)
            #on génére le code avec les appels de fonction encore parametrable
            #implique une dépendance au code calculant les apdus
            
        #level 2: rien n'est calculé, on execute via le shell
            #on est en niveau de script
            #besoin de l'ensemble du code

###########
### ... ###
###########


