
#################### EXECUTER ###################################################################################################

    ################
    ### executer ###
    ################
        #manage sigint, sigkill, ...
            #interrompre l'ensemble des process en cours
            #ou flinguer le courant et demander pour la suite
                #comme dans un terminal classique

            #sigint : ctrl-c
            #sigkill : ctrl-u
            #sigquit : ctrl-\

    #####################
    ### event manager ###
    #####################
        #system event
            #not removable
            #at startup, at exit, onContextChange, ...
            #could be empty

        #need to create the default event, the other part of the code are ready

#################### ADDON ###################################################################################################
    
    #################
    ### Procedure ###
    #################
            
        stored file is just ugly... (still the case ?)
        save the two type of command (will only contains one type of command in the futur)

    #################
    ### parameter ###
    #################
        
        for loading, set origin parameter from file
        
        prévoir un "reset" pour remettre les paramètre à ceux de démarrage
        
        be able to cypher the parameter file

    ###################
    ### addon addon ###
    ###################

        use tries to load addons

    #################
    ### Bash like ###
    #################  

    #needed for Procedure
        shift, set

    #go outside of shell scope, really needed ? (see brainstorming)
        loop, if, goto, ...

        not really needed, just need a simple way to jump from command to command is needed
        the advanced stuff (loop, if, object) is managed in python inside the command

    #################
    ### std addon ###
    #################      
        #gérer les commentaires, dans le parser plutot, non ?
            #voir shell.py (dans superShell, pas dans pyshell)
            
        #echo/echo16/toascii execut themself only in postprocess now
            #this is the better place to be executed
            #but this kind of function does not work: prox read 0 | pcs tran | echo16
                #the solution is echo16 | prox read 0 | pcs tran
                    #not intuitive at all...

        ## Help/usage

            #allow helping description on several lines
                #maybe it already works but need to test
                #the problem is the help print with several different command, only one line is allowed
                    #and currently, there is no filtering
                
            #auto generate and show in helping message, some example of method call
            
            #auto generate and show in help message which params need to be used with a dash

    ###################
    ### rfid addons ###
    ###################

        #adapter l'ensemble du code existant au nouveau shell
            #l'ensemble du code de rfidshell a été transféré dans apdu
                #non débuggé !!!
            #il reste à faire les addons pour pyshell
                #in progress

        #/System/Library/Frameworks/PCSC.framework/Versions/A/Headers/winscard.h
            le wrapper essaye de mapper une fonction qui n'existe pas dans la lib en C, on ne peut pas faire grand chose
                afficher un message pour dire que c'est normal
                oui mais le message d'erreur ne s'affiche pas toujours, comment savoir s'il s'est affiché ou non ?
                    idée: dupliquer le flux d'erreur et le parser lors du load de pcsc, si le message d'erreur est dedans, afficher une info pour dire que c'est normal
       
        #faire un système de gestion des codes d'erreurs
            à faire dans executeAPDU
            -pouvoir ajouter son propre handler d'erreur dans les modules  
            
            #!!!! ça existe dans pyscard, reutilisez
            
        #creer de nouveau event: oncardconnect, oncarddisconnect, onreaderconnect, onreaderdisconnect, ...
            #quand le systeme multi event sera implémenté
        
        #la commande wait est pourrie dans pyscard, ça fait friser le raspi
            #essayer de voir s'il n'y a pas moyen d'en faire une custom moins agressive
            #la commande actuelle bombarde le lecteur de isThereACard?, le bus de donnée finit par crasher...

        #faire des tests de multi process
            #lancer deux instances de l'application et essayer de se connecter à la même carte
                #pyscard est-il thread safe ? ou pcsc? chercher dans la doc
                
        #element faisant partie du contexte
            #type de lecteur
            #version du firmware du lecteur
            #type de carte
            #version de la carte
            #type de framew
            #...

#################### ARG #####################################################################################################

    #####################
    ### arg feeder    ###
    #####################

        #pouvoir générer un tries à partir du dico de parameter pour l'utiliser avec les "dashed parameter name" dans utils/solving

        #integrate default value in usage

#################### COMMAND #################################################################################################

    fixer/updater les tests unitaires

#################### LOADER ##################################################################################################

    #####################
    ### misc          ###
    #####################
    
        on parameter set, when origin loader is selected, not only the loader name is required, but also the profile name
            (?)
    
    #####################
    ### utils         ###
    #####################
    
        create a method to test the content of the loader
            this method will be called in the __main__ method of a module using the loader to check if everything is okay
        
            if __name__ == "__main__":
                loaders_checks()

                                 
#################### SYSTEM ##################################################################################################

    #####################
    ### Procedure     ###
    #####################
    
        find a way to hard kill a thread
            be carefull, ressource have to be released
            
        integrate settings system in procedure, to be able to save a procedure in the same way as a parameter
            see BRAINSTORMING FILE

    #####################
    ### parameter     ###
    #####################
        summary of BRAINSTORMING file (stuff to to in SYSTEM/LOADER/ADDON)
            On file loading (TODO in parameter addon)(step 3)
                if file is empty
                    store file name, hash of an empty file, and 0 parameter loaded from file
                if file does not exist
                    do nothing
                else
                    save file name, file hash and count the number of parameter loaded from file, then load
                    if an other NOT EMPTY EXISTING file was previously loaded, remove the informations of previous file and leave them empty
                        if already empty (because load of several file), do nothing, just load
                        empty information is not enough to know if several files were loaded or none at all
                
            In parameter (TODO in parameter system)(step 1) ONLY FOR GLOBAL SETTINGS
                store origin (loader name OR None if come from process)
                store parameter hash as soon as it been added in parameterManager
                store filePath hash (or None if does not come from file)
                NEVER update origin OR hash (except in loader overwrite, see bellow)
                
                add a banished list
                    need to hold three items per banished value
                        the banished value
                        the loader origin
                        the amount of times the value is banished
                    manage banished list in addValue/removeValue/setValue?/...
                        if a value is removed and come from a loader, put it in this list
                    method to add value in this list
                    need to save this list
                    
                add an unbanished list
                    manage unbanished list in addValue/removeValue/setValue?/...
                        if a value is removed from this list, put it in banished list 
                    manage value that was previously banished and that are not any more
                    don't save this list
                    the value of the unbanished list are present in the value list

                update loader list to manage index (see range value)
                    manage it in addValue/removeValue/setValue?/...
                    
                hash
                    banished list has to be used
                    value from loader should not be used
                    
            On loader loading (TODO in parameter loader)(step 2)
                if parameter does not exist, create it and register the loader in dependancies list
                    parameter has to be set to transient
                if parameter exists AND recreation disabled, just add the loader in the list dependancies
                if parameter exists AND recreation enabled, create a new parameter with a new origin and hash BUT keep the dependancies list
            
            On loader unloading (TODO in parameter loader)(step 2)
                if parameter does not exist, do nothing
                if parameter still exist AND not empty dependancies list THEN remove the current loader from list AND unload loader value
                if parameter still exist AND the current loader is alone in dependancies list AND parameter origin is loader AND hash is equal THEN remove it
                if parameter still exist AND the current loader is alone in dependancies list AND parameter origin is loader AND hash is NOT equal THEN remove current loader from list dependancies and remove loader value
                
            On file saving (TODO in parameter system)(step 3)   
                retrieve non transient Global parameter
                loop over these GlobalParameter
                    1) remove parameter from loader with hash equals to empty one (need to add a method to compute empty hash, for each type)
                        an empty one is: default settings, no value in list, no value in banished list
                    2) count parameter from file with equal hash as origin
                    3) count from procedure or with not equal hash as origin
                              
                case to save (if count of step 2) or 3) is bigger than 0)
                    information about origin file are empty
                    new destination file 
                    destination file does not exist
                    file hash is different in front of the hash computed in the starting of the sofware
                    at least one parameter with not equal hash
                    a parameter from procedure that was never stored
                    
                case to not save
                    still same output file, with same hash, with same amount of parameter from file with equal hash  
                    
                do not forget to set origin (so create command in addon)
                do not forget to set banished value (so create command in addon)

#################### UTILS ###################################################################################################

    #####################
    ### print service ###
    #####################

        #adapter printing pour pouvoir facilement utiliser le package log
            
        #gérer des trucs comme >, >>, 2>, 2>>, ...
            #changer le flux d'output pour la commande
            #le restaurer ensuiste
            #s'il y a deja un descripteur de fichier ouvert vers un fichier, le reutiliser
                #pour eviter d'avoir plusieurs descripteur vers le même fichier
                #et ainsi eviter d'avoir des overlaps dans le fichier

        #commande pour rediriger l'output vers un fichier
            #faire une commande de flush
            #flush and close at exit
            #si on fait un close, il faut retirer l'event at_exit
            
    #####################
    ### solving       ###
    #####################
    
        faire en sorte de pouvoir utiliser les prefix avec les dash_parameters (wait for refactoring of argFeeder)

#################### MISC ####################################################################################################

    #############################
    ### MISC                  ###
    #############################

        #in the unit test, check the exception message, there is a unit test method to do that 

        #not a real logic in exception usage, sometime DefaultPyshellException is used, and sometimes is is custom exception that inherit from DefaultPyshellException
            #define a usage way and always use it everywhere
            
            #IDEA 1 : each package has its exception module, these exception depends from utils/exception/PyshellException
                      And only these exception can be raised in their package

        #a lot of place in the code just raise default exception "raise Exception"
            #replace with pyshell exception raising
            
        #dans les tests, ne pas utiliser le type de base Exception dans les assertRaises
        
        #tous les noms de classe devraient commencer par une majuscule
        
        #remplacer "#!/usr/bin/python" par #!/usr/bin/env python -t
        
        #remplacer partout dans les lancements d'exceptions raise exc("(class name) ...") par raise exc("("+self.__class__.__name__+") ...")
     
    #############################
    ### DESIGN ISSUES         ###
    #############################
        1) how to parametrize on a return value ?
            e.g. : echo 1 2 3 | write
                if write has an address argument only available on dashed params ?
                
            the goal is to be able to set the adress from the echo, but is is not possible because only tokens are returned, not key/value

        2) not possible to do that:
            var add toto | echo 1 2 3

        because token "toto" will be sent to the pre of var, then pre of echo, then processed in echo post, and ...
            should be possible to set parameter for command var add, and set the key to toto
            with an argchecker, if it is possible to get an access to the engine, could be possible to get access to the current command object

            FIXED but need process in pre to store args

        3) not possible to do that:
            process | echo16

        because pro of process will never be executed, only process of echo16 will be

        SOLUTION1:
            could be possible to get access to previous command and execute its pro from current args
            COULD be possible to access to any command of the current engine execution

        SOLUTION2:
            double || to have similar behaviour as classical bash

        SOLUTION3:
            ... 

    #############################
    ### utilisation des tries ###
    #############################

    plusieurs mechanisme n'utilise pas les tries dans leur fonctionnement, c'est un peu dommage et ça casse la synergie du "tout en prefix"
        
        Where to update:
            -addon name (TODO)
            -dashed parameter name (TODO)
                dans solving
            -...

        look after dictionary init { everywhere in the code
            grep -r "{}" * | grep -v "~"
        
        IDEA (TODO ?)
            faire une fonction qui gère les ambiguité
                construire un message d'erreur generique a toute l'applic
                ce message contiendra l'ensemble des possibilités (ou un subset)
                
                l'objectif est de réduire la duplication de code du au tries pour la gestion des ambiguité

    ##########################################
    ### threading management brainstorming ###
    ##########################################

        #definition 
            #groupe de commande 
                #liste de 1 à n commande
            
            #process de lock
                #tous les locks sont connu
                #ils sont classé dans ordre précis
                #on les acquierent toujours dans le même ordre
                
            #lock static
                #exemple l'utilisation d'une fonction à accès unique dans une librairie
                
            #lock dynamique
                #un lecteur de carte, une carte a puce, ...

    ### NOT YET SOLVED ####

        #XXX    Quid des ressource dynamique necessitant un verrou d'utilisation
            #exemple une connexion vers une carte rfid
            
            #solution a la con
                #ne pas stocker de ressource devant avoir leur propre lock dans des structures ne possedant qu'un seul lock
                #dans le cas de la rfid, il suffirait de stocker les connexions et les cartes chacune dans un env indépendant
                    #du coup chaque objet aurait son lock, on augmente le threading et ça résoud le problème
                
        #quid de l'execution de deux instances de l'application...
            #objet partagé avec pyro ? chiant avec pyro, besoin d'une lib externe...
            #fichier de lock ?
            #analyse des process en memoire ? (need to be root)
            #flux de com en mémoire ?
            #...
            
        #pour l'instant les ressource seront lockée pour un single process
            #pas pour une commande, ni une multicommande, ni une piped commande, ni un procedureevent, ni ...
            #est ce le meilleur choix de design ?

##################################################################################################################################
##### futur work  ################################################################################################################
##################################################################################################################################

    #############################
    ### state machine process ### (OLD NAME : workflow, application)
    #############################
        #d'une certaine manière, une application dans le shell
            #possede un etat (creer un objet etat qui peut stocker plein de chose)
                #le stocker dans les parametres
                #le rendre transient ou non
                
            #creer un package pour stocker les app
            #possibilité d'en importer de l'exterieur
        
        #deux types d'app:
            #simple: chaque execution d'action ramene a l'etat initiale, une sorte de simple application
                #en fait c'est une complexe sans rien de défini
            
            #complexe: une action peut conduire vers un nouvel etat dans lequel seulement certaines actions sont possibles
                #definir dans quel cas on va où, et aussi gérer les cas d'erreur
                
        #action par defaut: startApp
            #disponible lorsque l'on se trouve dans le shell au démarrage avec le tries par défaut
            #cette action va remplacer le tries courant par celui de la machine à état
            #seule les actions de la state machine sont disponibles maintenant
            
        #action par defaut: exit
            #disponible uniquement dans une application
            #toujours disponible quelque soit l'etat de l'application
            #soit renvoi dans le shell
                #et restaure l'ancien tries
                
            #soit quitte completement le shell
            
        #action par defaut: reset
            #disponible uniquement dans une application
            #toujours disponible quelque soit l'etat de l'application
            #ramene a l'etat initial si possible
            #reset l'état de l'application
            
        #comment definir une action, que se passe t'il dedans? definir les liaison ? etc.
            #pourrait être interessant d'utiliser les decorations
            #TODO


    #########################
    ### service installer ###
    #########################

        #être en mesure d'activer des applications en tant que service
            #au démarrage entre autre
        
        #need to have a loop instruction
            #or could simply use the loop instruction in shell

        #manage deaemon system
            #think about log file, how and where to store it

            #-add argument to software entering point
                #-d start as daemon
                    #by default, a daemon must be a loop
                    #think to a system able to stop it easily   
                        #stop the daemon from command
                        #another argument -k (?)       
                
                #always need a file
                    #could be possible to set it in parameter

                #create an addon to manage daemon
                    #start, stop, restart, kill, list, ...
                    #be able to manage these action from command line

    ######################
    ### code generator ###
    ######################

        #génerer du code executable en dehors du shell
        
        #trois level de code executable:
            #level 0: un maximum de chose ont déjà été interprété (calcul d'apdu, de checksum, etc.)
                #il ne reste plus qu'à transmettre les données au framework
                #minimiser au maximum les imports en provenance du pyshell
                
            #level 1: rien n'a encore été calculé (calcul d'apdu, ...)
                #on génére le code avec les appels de fonction encore parametrable
                #implique une dépendance au code calculant les apdus
                
                créer un objet special capable de résoudre des path dans le tries, genre:
                    pytries_exec.con.sel.val("debug",0).pipe(pytries_exec.echo())
                    
                    ça devrait être possible en overridant des methodes style getAttr, __call__, ....
                
            #level 2: rien n'est calculé, on execute via le shell
                #on est en niveau de script
                #besoin de l'ensemble du code

    ################
    ### other... ###
    ################


