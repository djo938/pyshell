
#################### EXECUTER ###################################################################################################

    ################
    ### executer ###
    ################
        #manage sigint, sigkill, ...
            #interrompre l'ensemble des process en cours
            #ou flinguer le courant et demander pour la suite
                #comme dans un terminal classique

    #####################
    ### event manager ###
    #####################
        #system event
            #not removable
            #at startup, at exit, onContextChange, ...
            #could be empty

        #need to create the default event, the other part of the code are ready

#################### ADDON ###################################################################################################
    
    #################
    ### Procedure ###
    #################
            
        stored file is just ugly... (still the case ?)
        save the two type of command

    #################
    ### parameter ###
    #################
        
        for loading, set origin parameter from file
        
        prévoir un "reset" pour remettre les paramètre à ceux de démarrage
        
        be able to cypher the parameter file

    ###################
    ### addon addon ###
    ###################

        use tries to load addons

    #################
    ### Bash like ###
    #################  

    #needed for Procedure
        shift, set

    #go outside of shell scope, really needed ? (see brainstorming)
        loop, if, goto, ...

    #################
    ### std addon ###
    #################      
        #gérer les commentaires, dans le parser plutot, non ?
            #voir shell.py
            
        #echo/echo16/toascii execut themself only in postprocess now
            #this is the better place to be executed
            #but this kind of function does not work: prox read 0 | pcs tran | echo16
                #the solution is echo16 | prox read 0 | pcs tran
                    #not intuitive at all...

        ## Help/usage

            #allow helping description on several lines
                #maybe it already works but need to test
                #the problem is the help print with several different command, only one line is allowed
                    #and currently, there is no filtering
                
            #auto generate and show in helping message, some example of method call
            
            #auto generate and show in help message which params need to be used with a dash

    ###################
    ### rfid addons ###
    ###################

        #adapter l'ensemble du code existant au nouveau shell
            #l'ensemble du code de rfidshell a été transféré dans apdu
                #non débuggé !!!
            #il reste à faire les addons pour pyshell
            #in progress

        #/System/Library/Frameworks/PCSC.framework/Versions/A/Headers/winscard.h
            le wrapper essaye de mapper une fonction qui n'existe pas dans la lib en C, on ne peut pas faire grand chose
                afficher un message pour dire que c'est normal
                oui mais le message d'erreur ne s'affiche pas toujours, comment savoir s'il s'est affiché ou non ?
       
        #faire un système de gestion des codes d'erreurs
            à faire dans executeAPDU
            -pouvoir ajouter son propre handler d'erreur dans les modules  
            
            #!!!! ça existe dans pyscard, reutilisez
            
        #creer de nouveau event: oncardconnect, oncarddisconnect, onreaderconnect, onreaderdisconnect, ...
            #quand le systeme multi event sera implémenté
        
        #la commande wait est pourrie dans pyscard, ça fait friser le raspi
            #essayer de voir s'il n'y a pas moyen d'en faire une custom moins agressive

        #faire des tests de multi process
            #lancer deux instances de l'application et essayer de se connecter à la même carte
                #pyscard est-il thread safe ? ou pcsc?
                
        #element faisant partie du contexte
            #type de lecteur
            #version du firmware du lecteur
            #type de carte
            #version de la carte
            #type de framew
            #...

#################### ARG #####################################################################################################

    #####################
    ### arg feeder    ###
    #####################

        pouvoir générer un tries à partir du dico de parameter pour l'utiliser avec les "dashed parameter name" dans utils/solving

        integrate default value in usage

#################### COMMAND #################################################################################################

    fixer/updater les tests unitaires

#################### LOADER ##################################################################################################

    #####################
    ### misc          ###
    #####################
    
        on parameter set, when origin loader is selected, not only the loader name is required, but also the profile name
    
    #####################
    ### utils         ###
    #####################
    
        create a method to test the content of the loader
            this method will be called in the __main__ method of a module using the loader to check if everything is okay
        
            if __name__ == "__main__":
                loaders_checks()

    #####################
    ### parameter     ###
    #####################
        SUMMARY
            On file loading (TODO in parameter addon)(step 3)
                if file is empty, do nothing
                save file name, file hash and count the number of parameter loaded from file, then load
                if an other file was previously loaded, remove the informations of previous file and leave them empty
                    if already empty, do nothing, just load
                
            In parameter (TODO in parameter system)(step 1) DONE
                store origin (loader + name OR File + name OR Procedure + None)
                store parameter hash at its creation
                NEVER update origin OR hash (except in loader)
                
            On loader loading (TODO in parameter loader)(step 2)
                if parameter does not exist, create it and register the loader in dependancies list
                if parameter exists AND recreation disabled, just add the loader in the list dependancies
                if parameter exists AND recreation enabled, create a new parameter with a new origin and hash BUT keep the dependancies list
            
            On loader unloading (TODO in parameter loader)(step 2)
                if parameter does not exist, do nothing
                if parameter still exist and not empty dependancies list, just remove the current loader from list
                if parameter still exist and empty dependancies list (only store the current loader), if parameter origin is loader and hash is equal, remove it
                if parameter still exist and empty dependancies list (only store the current loader), if parameter origin is loader and hash is NOT equal, only remove current loader from list dependancies and do nothing else
                
            On file saving (TODO in parameter system)(step 3)   
                retrieve non transient Global parameter
                remove parameter from loader with equal hash as origin
                count parameter from file with equal hash as origin
                count from procedure or with not equal hash as origin
                              
                case to save
                    if information about origin file are empty
                    if new destination file OR destination file does not exist OR file hash is not equal
                    if at least one parameter with not equal hash or from procedure
                    
                case to not save
                    still same output file, with same hash, with same amount of parameter from file with equal hash
    
                        
        About history (after brainstorming, it is not really an history, it is value origin)
            WHY?
                PBLM 1 how to know if is it necessary to recreate stored config or not ? SOLVED
                    for not transient parameter, we have to know if the final value is different of the original value

                    SOLUTION
                        generate a hash of the parameter file on loading and compare it with a new hash at the saving process
                            if hash is equal and no difference in parameter AND there is no new candidate to be saved, don't save at exit
                            also keep the filePath, if a different parameter file is loaded OR the file destination is different, save at exit

                            count the number of parameter loaded from file, if there is less or more at the saving time, recreate the parameter file
                                if the number is equal from the loading, don't save

                        add a single couple of data to parameter about current value origin OR properties origin, here are the possible values: (NEW FIELD: origin)
                            System         + None 
                            File           + filePath
                            Loader         + addonName
                            Procedure      + None

                        ABSOLUTLY SAVE IN FOLLOWING CASES:
                            Origin=Procedure
                            Origin=File AND path is different of the destination file
                        
                        CANDIDATE FOR SAVING BUT DO NOT TRIGGER IT IN FOLLOWING CASES:
                            Origin=File AND path is the same of the destination file And exactly the same count of parameter loaded
                            
                        DON'T SAVE IN FOLLOWING CASES:
                            Origin=System
                            Origin=Loader

                        add a boolean "force" on removeParameter in container
                            if true, remove the parameter in anyway
                            if false AND there is at least one loader register, raise

                PBLM 2 loader add/create parameter on loading and should remove then on unloading SOLVED
                    except if another element update the value (custom update, other addon, ...)

                    not exactly, the problem is if two or several different addons want to create a parameter with the same key
                        the first loaded addon will create the parameter
                        the others parameter won't create again the parameter
                        if the first loaded addon is unloaded, it will remove the parameter, the other addons won't


                    SOLUTION
                        record a list of addon that need this parameter (NEW FIELD)
                        and only removed the parameter on the last addon unloading (or program exit) AND if the current value origin is Addon
                            an addon record itself in the list, or remove itself from the list through the loader system

                        on statup ONLY, if a value exist from file, it can't be overwritte by an addon
                            after the startup, if an addon is loaded, it could overwritte the value
                                need to find a way to say to the loader that this is the startup procedure
                                ideally forbide to execute startup a second time

                PRBLM 3: if we just overwritte the full parameter, not only set a new value
                         setParameter from container in place of setValue from parameter
                    
                    it will overwrite the information stored into the parameter
                        the information about loader, a simple list

                    SOLUTION 1: if parameter already exists, manage it into the container and merge information from old one with the new one XXX
                    SOLUTION 2: store these information outside of the parameter, so you will never lose them
                    
                    the SOLUTION 1 is better and simpler, because just need to store a list
                        So when a parameter want to overwrite an existing one, just merge loader list
                    
                PRBLM 4: how to know where the update come from ?
                    for "System" and "Loader", it is easy because the parameter setting occurs in a well defined place.
                    for "Procedure", it has to be the default origin, so no need to create specific mechanism
                    for "File", it is the real problem, because the process loading occured into a process that occur into a file procedure
                        we have no information to give to the parameterManager about the file origin
                        
                    SOLUTION 1: add an argument on command "set parameter" about origin
                        +++ simple do install
                        --- show an internal mechanism to the user
                        --- a user could update origin in parameter file and break the logics of this stuff
                        
                    SOLUTION 2: create a local var to indicate the origin of the next parameter
                    SOLUTION 2b: create an hidden command to indicate to the parameter manager that every following parameter will come from file
                        And create another hidden command to indicate the loading is finished
                        
                        Yeah but what does occur if a crash happend during parameter loading ? there is a risk to never reset parameter origin
                            not really, a file loading run with a granularity of None, so the call will never stop to execute until the end of the file
                            
                        these command call could be added by the parameter process that create the alias object at the begging and end of this alias
                        
                    SOLUTION 3: create a method in parameterManager to setOriginOfParameter XXX
                        this information will be used to set the origin of every parameter for the current thread only
                            so at the end of the thread life, this information disappear
                            
                        set it in the process to load the file
                        use it everywhere, for Loader, System, Process, File
                        Default Value => Process
                        
                        create a hidden method getOriginParameter that will be used by parameterManager
                            this method also need to be called in parameter during setValue or setProperties or related function

                PRBLM 5: if a loader just update a properties, the object origin will be flagged "from loader"
                    But maybe the value or another properties of this object was set from a procedure and has to be saved on file...

                    SOLUTION 1: each properties/value has an origin, not only the full object
                        --- aouch, increase memory usage, should be possible to find a smarter solution

                    SOLUTION 2: 
                         reduce origin seed: system/loader are the same kind, keep file and procedure
                         if a parameter is flagged system/loader, just store the flag
                         if a parameter is flagged procedure/file, keep a list of flagged properties name
                            until at least one item is flaggeg procedure/file, the whole parameters is flagged like that

                        procedure > file > loader

                            even if everything is flagged file except one thing that is flagged procedure
                            the parameter remains flagged procedure

                        if every properties are flagged procedure or file, keep an empty list of properties name

                        What about two files origin ?

                        --- could still use a lot of memory even if it is in a smarter way

                    SOLUTION 3: keep a variable with the origin of the creator of the param
                        at exit, the creator of the parameter will check if the parameter created has changed, if yes, the parameter is flagged as "TO SAVE"

                        have to unload parameter in the opposite order as the loading

                        PRBLM 1: if the loader responsible for a parameter is already unloaded before the unloading process ?
                        PRBLM 2: what about files? the original copy of the parameter is stored on disk, maybe a change occured on the file
                                 between loading and unloading

                    SOLUTION 4: keep the creator origin and the hash of the parameter at its creation XXX
                        if system/loader origin and no diff of the hash, don't save
                        if file origin and no diff of the hash, candidate to be saved
                        if process and no diff of the hash, to absolutely save

                        if diff on the hash, absolutely save

                        +++ no extra data in memory
                        +++ simple process at exit, just recompute the hash and compare
                        +++ easy to implement

                        PRBLM 1: if the object is updated BUT because of the loading of an addon
                            the parameter does not need to be saved but the hash will be different

                            SOLUTION 1 : if a loader recreate a parameter, overwrite the origin and the hash in parameter

                PRBLM 6: add/remove some of the values TODO
                    it's not a complete "setValue"
                    
                    SOLUTION 1: keep a start index, and a end index of value stored by each 
                        because it is not allowed to add value at a specific index in environmentParameter, you can only add/remove value
                        So we don't need more information
                        could be possible to set: -a single value (range length = 1)
                                                  -a range value (range length > 1)
                                                  -all value (range length = max)
                                                  -No value (range length = 0)
                                                  
                        even if all the value added by a loader are removed, the loader is still dependant of the parameter
                        
                        QUESTION: with such system, we will precisely know at the save which value come from the loader
                            Is loader origin/hash still needed ? because we will be able to identify precisely every value in the parameter coming from a loader
                            startingHash is still needed to know if file is different from file, still need to know file name
                            if does not come from file, set hash to None
                            origin not really needed anymore for loader or procedure
                            
                        PRBLM 1: if a user removed a value added by a loader, it becomes a custom parameter or not ?
                            because on the next reboot, the removed value will come back
                            but if we store loader value, then reload them, they will become value from file and not from loader...
                        
                        PRBLM 2: And if add it after the removal ? does it come back to the loader origin ? 
                            definitely not
                            
                            
                            
#################### SYSTEM ##################################################################################################

    #####################
    ### Procedure     ###
    #####################
    
       find a way to hard kill a thread
            be carefull, ressource have to be released
            
        PROBLEME des settings, ce serait bien de les intégrer de la même manière que dans les parameters, en tout cas les ProcedureFromList
            
            WHAT DO WE WANT ?
                a loader can add command in a procedure
                a loader can be unloaded and so remove its command from the procedure
                    so a loader should be able to identify its commands
                    OR a command should be identified as part of a loader
                    
                    a command could disappear before the unloading of the loader (manually removed or removed by another loader or ...)
                    a command could move in the procedure if command are inserted or removed with a lower index
                    
                    How to make the link between a loader and a command ? **PRBLM**
                    
                a procedure can be saved on file
                    need to know if a procedure need to be saved on drive => compute hash after the creation of a command and adding all the commands => setStartingHash
                    be careful with the procedure only fulled in with loader commands
                    
                loader command shouldn't saved on file
                    do not use the command added by loader in the hash process, so these commands must be tagged **PRBLM**

            PRBLM How to make the link between a command and a loader to remove it on loader unload and avoid them in hashing process ?
                SOLUTION 1: les flagger avec un booleen
                    PRBLM: not enough information
                
                SOLUTION 2: garder une liste d'index les concernant
                    PRBML: les index peuvent bouger
                
                SOLUTION 3: découper les procedures en deux parties USER/LOADER
                    Et ne sauvegarder que la partie User s'il y en a une
                    fixe le problème des saves, pas besoin d'unloader les loaders a la fermeture du programme
                    
                    PRBLM 1: si loop ou exception ou exit dans le user space
                    PRBLM 2: implique encore d'ajouter une couche de gestion en +, l'ideal serait de gérer ça dans les class existante
                    
                SOLUTION 4: les unloader lors de l'unload des loaders, les données chargées par les loaders sont supposées dynamiques
                    PRBLM: need to absolutely register unload at exit
            
                SOLUTION 5: add the identity of the loader as a extra attribute of the command object in the procedure  XXX best one for the moment
                    so, the command without this extra attribute does not come from a loader
                    and if this attribute exist, it identifies uniquely a loader
                    
                    --- adding an hidden attribute is ugly
                    +++ no extra structure for the command coming from non loader seed
                    +++ easy to manage


                    PRBLM: how to access easily to the method to remove in case of loader unloas ?
                        whitout need to iterate over every remaining command in the list ?
                

                SOLUTION 6: 
                    a command added by a loader is flagged
                        so command flagged are not used in hash or in saving process

                    the flagging hold: -ref to the index list of the loader
                                       -index of the command in the index list

                    a list of index (for each loader)
                        a list of the index of the command of this loader in the procedure

                    ACTION
                        on loader load
                            flag the command
                            add them in the list of index
                            set their index in the list of index

                        on loader unload
                            took the last command, remove it from the procedure
                            remove list of index
                            update list of index of the other loaders after the first command of the removed loader
                                uuuh, could be an issues, because the index of the others loader are maybe invalid now ... TODO
                                    update the index of the other loader in the same time of removing the command of the unloaded loader

                        on command remove (command from a loader)
                            remove the command from the index list
                            update index of every loaders after the index of remove one
                                update them from the end of each list, except for the current one

                        on command move
                            update index in command
                            if the command is twisted with other command of the same loader, need to update order in queue
                            also need to update index of command of this loader and the others

                        on command add/move/remove (command not from a loader)
                            need to identify loader command after the command added/removed TODO
                            and update their index

                    LINKING ?
                        from first to last
                            00 one reference to store
                            00 on loader unload, need to recompute every index of the next command to remove (not really difficul to recompute)
                            ++ on command remove, easy to access to following command where index need to be updated
                            -- on command remove, need to link previous command to next one, but no reference to previous one

                        from last to first
                            00 one reference to store
                            ++ on loader unload, can remove every command without index recomputation
                            00 on command remove, need to iterate from the last command until we found the removed command (no more complexity than fToL)
                            -- on command remove, need to link previous command to next one, but no reference to next one

                        both XXX
                            -- two references to store
                            00 more thing to manage on move (no really more things to manage)
                            ++ easy to remove a command one
                            ++ easy to move a command
                            00 on addon unload, same difficulty as other linkings

                        list of index + command know its index in the list on index XXX
                            memory advantage of simple queue
                            same algorithm advantage of double queue


#################### UTILS ###################################################################################################

    #####################
    ### print service ###
    #####################

        #adapter printing pour pouvoir facilement utiliser le package log
            
        #gérer des trucs comme >, >>, 2>, 2>>, ...
            #changer le flux d'output pour la commande
            #le restaurer ensuiste
            #s'il y a deja un descripteur de fichier ouvert vers un fichier, le reutiliser
                #pour eviter d'avoir plusieurs descripteur vers le même fichier
                #et ainsi eviter d'avoir des overlaps dans le fichier

        #commande pour rediriger l'output vers un fichier
            #faire une commande de flush
            #flush and close at exit
            #si on fait un close, il faut retirer l'event at_exit
            
    #####################
    ### solving       ###
    #####################
    
        faire en sorte de pouvoir utiliser les prefix avec les dash_parameters (wait for refactoring of argFeeder)

#################### MISC ####################################################################################################

    #############################
    ### MISC                  ###
    #############################

        #not a real logic in exception usage, sometime DefaultPyshellException is used, and sometimes is is custom exception that inherit from DefaultPyshellException
            #define a usage way and always use it everywhere

        #a lot of place in the code just raise default exception "raise Exception"
            #replace with pyshell exception raising
            
        #dans les tests, ne pas utiliser le type de base Exception dans les assertRaises
        
        #tous les noms de classe devraient commencer par une majuscule
        
        #remplacer "#!/usr/bin/python" par #!/usr/bin/env python -t
        
        #remplacer partout dans les lancements d'exceptions raise exc("(class name) ...") par raise exc("("+self.__class__.__name__+") ...")
     
    #############################
    ### DESIGN ISSUES         ###
    #############################
        1) how to parametrize on a return value ?
            e.g. : echo 1 2 3 | write
                if write has an address argument only available on dashed params ?
                
            the goal is to be able to set the adress from the echo, but is is not possible because only tokens are returned, not key/value

        2) not possible to do that:
            var add toto | echo 1 2 3

        because token "toto" will be sent to the pre of var, then pre of echo, then processed in echo post, and ...
            should be possible to set parameter for command var add, and set the key to toto
            with an argchecker, if it is possible to get an access to the engine, could be possible to get access to the current command object

            FIXED but need process in pre to store args

        3) not possible to do that:
            process | echo16

        because pro of process will never be executed, only process of echo16 will be

        SOLUTION1:
            could be possible to get access to previous command and execute its pro from current args
            COULD be possible to access to any command of the current engine execution

        SOLUTION2:
            double || to have similar behaviour as classical bash

        SOLUTION3:
            ... 

    #############################
    ### utilisation des tries ###
    #############################

    plusieurs mechanisme n'utilise pas les tries dans leur fonctionnement, c'est un peu dommage et ça casse la synergie du "tout en prefix"
        
        Where to update:
            -addon name (TODO)
            -dashed parameter name (TODO)
                dans solving
            -...

        look after dictionary init { everywhere in the code
            grep -r "{}" * | grep -v "~"
        
        IDEA (TODO ?)
            faire une fonction qui gère les ambiguité
                construire un message d'erreur generique a toute l'applic
                ce message contiendra l'ensemble des possibilités (ou un subset)
                
                l'objectif est de réduire la duplication de code du au tries pour la gestion des ambiguité

    ##########################################
    ### threading management brainstorming ###
    ##########################################

        #definition 
            #groupe de commande 
                #liste de 1 à n commande
            
            #process de lock
                #tous les locks sont connu
                #ils sont classé dans ordre précis
                #on les acquierent toujours dans le même ordre
                
            #lock static
                #exemple l'utilisation d'une fonction à accès unique dans une librairie
                
            #lock dynamique
                #un lecteur de carte, une carte a puce, ...

    ### NOT YET SOLVED ####

        #XXX    Quid des ressource dynamique necessitant un verrou d'utilisation
            #exemple une connexion vers une carte rfid
            
            #solution a la con
                #ne pas stocker de ressource devant avoir leur propre lock dans des structures ne possedant qu'un seul lock
                #dans le cas de la rfid, il suffirait de stocker les connexions et les cartes chacune dans un env indépendant
                    #du coup chaque objet aurait son lock, on augmente le threading et ça résoud le problème
                
        #quid de l'execution de deux instances de l'application...
            #objet partagé avec pyro ? chiant avec pyro, besoin d'une lib externe...
            #fichier de lock ?
            #analyse des process en memoire ? (need to be root)
            #flux de com en mémoire ?
            #...
            
        #pour l'instant les ressource seront lockée pour un single process
            #pas pour une commande, ni une multicommande, ni une piped commande, ni un procedureevent, ni ...
            #est ce le meilleur choix de design ?

##################################################################################################################################
##### futur work  ################################################################################################################
##################################################################################################################################

    #############################
    ### state machine process ### OLD NAME : workflow, application
    #############################
        #d'une certaine manière, une application dans le shell
            #possede un etat (creer un objet etat qui peut stocker plein de chose)
                #le stocker dans les parametres
                #le rendre transient ou non
                
            #creer un package pour stocker les app
            #possibilité d'en importer de l'exterieur
        
        #deux types d'app:
            #simple: chaque execution d'action ramene a l'etat initiale, une sorte de simple application
                #en fait c'est une complexe sans rien de défini
            
            #complexe: une action peut conduire vers un nouvel etat dans lequel seulement certaines actions sont possibles
                #definir dans quel cas on va où, et aussi gérer les cas d'erreur
                
        #action par defaut: startApp
            #disponible lorsque l'on se trouve dans le shell au démarrage avec le tries par défaut
            #cette action va remplacer le tries courant par celui de la machine à état
            #seule les actions de la state machine sont disponibles maintenant
            
        #action par defaut: exit
            #disponible uniquement dans une application
            #toujours disponible quelque soit l'etat de l'application
            #soit renvoi dans le shell
                #et restaure l'ancien tries
                
            #soit quitte completement le shell
            
        #action par defaut: reset
            #disponible uniquement dans une application
            #toujours disponible quelque soit l'etat de l'application
            #ramene a l'etat initial si possible
            #reset l'état de l'application
            
        #comment definir une action, que se passe t'il dedans? definir les liaison ? etc.
            #pourrait être interessant d'utiliser les decorations
            #TODO


    #########################
    ### service installer ###
    #########################

        #être en mesure d'activer des applications en tant que service
            #au démarrage entre autre
        
        #need to have a loop instruction
            #or could simply use the loop instruction in shell

        #manage deaemon system
            #think about log file, how and where to store it

            #-add argument to software entering point
                #-d start as daemon
                    #by default, a daemon must be a loop
                    #think to a system able to stop it easily   
                        #stop the daemon from command
                        #another argument -k (?)       
                
                #always need a file
                    #could be possible to set it in parameter

                #create an addon to manage daemon
                    #start, stop, restart, kill, list, ...
                    #be able to manage these action from command line

    ######################
    ### code generator ###
    ######################

        #génerer du code executable en dehors du shell
        
        #trois level de code executable:
            #level 0: un maximum de chose ont déjà été interprété (calcul d'apdu, de checksum, etc.)
                #il ne reste plus qu'à transmettre les données au framework
                #minimiser au maximum les imports en provenance du pyshell
                
            #level 1: rien n'a encore été calculé (calcul d'apdu, ...)
                #on génére le code avec les appels de fonction encore parametrable
                #implique une dépendance au code calculant les apdus
                
                créer un objet special capable de résoudre des path dans le tries, genre:
                    pytries_exec.con.sel.val("debug",0).pipe(pytries_exec.echo())
                    
                    ça devrait être possible en overridant des methodes style getAttr, __call__, ....
                
            #level 2: rien n'est calculé, on execute via le shell
                #on est en niveau de script
                #besoin de l'ensemble du code

    ################
    ### other... ###
    ################


