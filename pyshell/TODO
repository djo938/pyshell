ArgChecker
    -test : OK
    -dans les argChecker, quand il y a une erreur, insérer systèmatiquement la valeur foireuse dans l'exception : TO CHECK
    
ArgChecherS
    -test : OK

Decorator
    -test : OK
    -check this : OK
    -clean code : OK

Command
    -clean selfArgChecker : OK
    -permettre de transfèrer des informations entre les pre et les post
        -exemple, pre2 a besoin d'info provenant de post1
            C'est a post1 de lui transmettre
        -cas de figure : lecture d'un fichier en plusieurs etape, ou une auth, ... 
            -desfire
        faire une class special qui fourni le même genre de service que la classe MultiCommand
            histoire d'avoir une abstraction et de ne devoir rien changer d'autre
            ??? qu'est ce que j'ai voulu dire ?

        #XXX il faut que les methods(pre/pro/pos) puissent avoir acces à leur input buffer(pre)...
            #ou pouvoir ajouter des methodes dans le listing ?
                #plus puissant mais impliquerait de calculer la structure des pipes à la vollée
                    #pas un prblm
                #on peut faire les deux
            #pour les buffer, on peut faire ça par argChecker special
                #uniquement acces au buffer d'input
                    #risque de boucle infinie du coup si la meth remplie elle meme sont buffer d'input
                        #limiter le nombre d'exec
                #binder a l'exec
                        
        #XXX pour l'interruption, on peut mettre un system par exception
            raise normalRunningStop()
            raise abnormalRunningStop()
            ...
            
        #XXX permettre egalement d'avoir acces au buffer d'input de la commande suivante
        
    #XXX donc, triple mecanisme (pas oublier de relire la reflection quand meme) :
        va permettre de faire les mêmes choses de manière différente si on veut
    
        A) on va pouvoir binder un parametre special (en pre/pro/pos) pour avoir acces a un objet special qui offrira les services suivants:
            -avoir acces au buffer input de la commande courante
                limiter le nombre déxecution max d'une commande
            -avoir acces au buffer input de la commande suivante
                et uniquement, interdiction d'injecter des données a une commande n+2
            -pouvoir ajouter une commande dans le listing des commandes
            -accéder aux variables d'état de l'execution 
            -avoir acces à l'env (get, set, but no creation)
                un seul argchecker pour tout faire du coup
            
            sera binder a l'execution
        
        B) Pour communiquer entre pre/pro/pos, les methodes doivent juste faire partie du même objet 
            et communiquer comme elles veulent au travers de celui-ci (via le self)
            peuvent juste ovverider la class Command
            
            probleme de remanence des donnees si on execute plusieurs fois la commande
                il faut faire un systeme de reinit
                
            pas d'interet pour la pre de parler avec la post de la meme commande puisqu'il se transfere des donnees
            par contre ça devient interessant si la commande se repete plusieurs fois
            
        C) Un système d'exception permettant d'interrompre une execution à partir de n'importe où
             raise normalRunningStop()
             raise abnormalRunningStop()
             ...

        D) les commandes peuvent renvoyer un résultat de type multiOutput (systeme deja en place)
            les fonctions suivantes seront appelées autant de fois qu'il y a d'output
            pratique pour la lecture d'un fichier ou l'execution suivante ne se soucie du résultat precedant
            pas pratique dans le cas d'une authen ou la seconde pass a besoin du résultat de la premiere pass

        X) au lieu de faire des listes de listes, plutôt faire un arbre pour ne pas réexecuter 
           plusieurs fois les même pre/post.
           => sauf si le resultat change a chaque execution avec des parametres similaire
                faire un decorateur speciale pour ces fonctions là et adapater l'arbre en conséquence
           parcourir l'arbre avec un traversal permettant d'explorer en fonction de l'ordre d'ajout
           l'arbre devient le buffer
           possibilité de retirer les branches au fure et à mesure de l'exploration ?
                non pas vraiment, car on finit toujours avec le post de la premiere instruction
                    sauf si on fait 2 arbres, les listes sont plus pratiques dans ce cas ci :/
                    a reflechir
           les noeuds feuilles seraient les process a executer
           plusieurs traversal possible
                le plus logique est :
                    on descend jusqu'en bas et on remonte jusqu'en haut a chaque fois
                    ensuite on repart des points d'arret qu'on aura repéré
                        on prend quel point d'arrêt en premier? 
                            d'abord les post les plus haut dans l'arbre, ensuite les pre les plus basses
                    Qu'est ce qu'un point d'arret ?
                        a chaque fois qu'il y aura un embranchement il faudra marqué ça comme un point d'arret alors ?
                            ça va faire une sacré liste
            On place ça dans une priority Queue (heapq)
            
Executeur
    -faire une liste d'alias
        description dans le code
    -l'autocomplétion
    -gérer des trucs comme >, >>, ...
    -quand il y a une ambiguité sur une commande, afficher directement les possibilités
    -n'afficher que les commandes terminal dans l'aide, comme dans le shell du proxmark
        -utiliser le setStopTraversal dans les mltries
        -l'aide doit s'arreter là et afficher un subset des clés
            mettre une empty command avec un message __doc__ personnalisé
        -lors du insertion, mettre a jour tout les noeuds parents vide
    -l'env doit être un triplet clé, valeur, type
        permettre de creer des triplets en definissant le type
    
    
Shell
    -créer les commandes manquantes
        voir fichier

RFID
    /System/Library/Frameworks/PCSC.framework/Versions/A/Headers/winscard.h
        le wrapper essaye de mapper une fonction qui n'existe pas dans la lib en C, on ne peut pas faire grand chose
   
   - faire un système de gestion des codes d'erreurs
	    à faire dans executeAPDU

   -faire un système de décapsulation des réponses
	    +- en place

    -manage error code
	    -pouvoir ajouter son propre handler d'erreur

TEST
    en faire tout plein :)
	    
######################################################

??? Executeur ou ArgChecherS ? entre les deux ?
    -permettre a l'utilisateur de binder uniquement certains argument
        exemple:
            cmd(a,b,c=None,d=None,e=None)
            
        cmd ValueA ValueB -e ValueE
        
        attention aux nombres négatif -5, -42.23, ...
        attention au cas ou on a un arg en dernier de liste
        attention au cas ou on a deux (ou plusieurs) param qui se suivent -a -c -d

        PRBLM on a un risque de perte d'information si on utilise le - comme marqueur de parametre
            si on melange les argument avec parametre et ceux sans
            example : cmd toto(<string> ... <string>2) tata:<string>
                toto -tata d a b c 
                    -tata is a part of the list or the last argument ?
            
            def "nom de param" :
                - commence par un tiret
                - est directement suivi (donc pas d'espace) par le prefix du nom d'un argument existant
                - est suivi par au moins un non "non de param" (ne repondant pas aux deux criteres precedents)
                    exception pour le boolean, la presence sans valeur implique "True"
            
            SOLUTION 1
                le tiret est un caractere reservé
                on peut l'escaper en faisant \-
                    et si on veut recuperer \-, on devra encoder \\-, etc.
                    
            SOLUTION 2
                les arguments parametré le sont uniquement a la fin
                on commence a parser à partir de la fin jusqu'a ne plus trouver d'arg parametre
                et on recommence a parser a partir du debut les args manquant
                
            SOLUTION 3 <===
                a) on identifie tous les params existant
                    faire une liste des indices
                b) on place les params erronés dans une liste (pour gestion en cas d'erreur)
                c) on inteprète tous les params identifié
                d) si pas d'erreur, on interprete tout ce qui reste avec l'ancienne methode
                    les params erronés sont utilisables dans la liste comme un token normale
                
                englobe la solution 1 et 2
                PROBLEM si on essaye de binder une liste avec liste infinie, ou avec une taille min inferieur a la max, et justement on transfere le min
                    et qu'il y a encore des arguments après
                    
                    SOLUTION 1
                        on s'arrete au prochain param token identifié
                            et s'il n'y en a pas ? jusqu'au bout du flux ou de la limite

                    SOLUTION 2 
                        on defini une taille après le param genre -toto:5
                            ça demande d'ajouter une info en + alors...
                                c'est chiant

    !!!! ne devrait rien changer au decorateur, ArgChecker et argFeeder !!!
        ils fournissent juste un outils de verification de l'argument, des valeurs par defaut et des noms
        le argFeeder se charge juste de faire le binding, les valeurs paramètrées doivent être retirée avant, on fait une couche suplémentaire par dessus
            devra se trouver juste après la recherche de commande
            et juste avant le argfeeder

       

    


