### executer ###
	#alias pointant sur 1..n commande(s)
        faire une liste d'alias
            description dans le code
    #l'autocomplétion
    #gérer des trucs comme >, >>, ...
    #quand il y a une ambiguité sur une commande, afficher directement les possibilités
    #n'afficher que les commandes terminal dans l'aide, comme dans le shell du proxmark
        utiliser le setStopTraversal dans les mltries
        l'aide doit s'arreter là et afficher un subset des clés
            mettre une empty command avec un message __doc__ personnalisé
        lors du insertion, mettre a jour tout les noeuds parents vide
    #l'env doit être un triplet clé, valeur, type
        permettre de creer des triplets en definissant le type

### parameter in command call ###

    ??? Executeur ou ArgChecherS ? entre les deux ?
    -permettre a l'utilisateur de binder uniquement certains argument
        exemple:
            cmd(a,b,c=None,d=None,e=None)
            
        cmd ValueA ValueB -e ValueE
        
        attention aux nombres négatif -5, -42.23, ...
        attention au cas ou on a un arg en dernier de liste
        attention au cas ou on a deux (ou plusieurs) param qui se suivent -a -c -d

        PRBLM on a un risque de perte d'information si on utilise le - comme marqueur de parametre
            si on melange les argument avec parametre et ceux sans
            example : cmd toto(<string> ... <string>2) tata:<string>
                toto -tata d a b c 
                    -tata is a part of the list or the last argument ?
            
            def "nom de param" :
                - commence par un tiret
                - est directement suivi (donc pas d'espace) par le prefix du nom d'un argument existant
                - est suivi par au moins un non "non de param" (ne repondant pas aux deux criteres precedents)
                    exception pour le boolean, la presence sans valeur implique "True"
            
            SOLUTION 1
                le tiret est un caractere reservé
                on peut l'escaper en faisant \-
                    et si on veut recuperer \-, on devra encoder \\-, etc.
                    
            SOLUTION 2
                les arguments parametré le sont uniquement a la fin
                on commence a parser à partir de la fin jusqu'a ne plus trouver d'arg parametre
                et on recommence a parser a partir du debut les args manquant
                
            SOLUTION 3 <===
                a) on identifie tous les params existant
                    faire une liste des indices
                b) on place les params erronés dans une liste (pour gestion en cas d'erreur)
                c) on inteprète tous les params identifié
                d) si pas d'erreur, on interprete tout ce qui reste avec l'ancienne methode
                    les params erronés sont utilisables dans la liste comme un token normale
                
                englobe la solution 1 et 2
                PROBLEM si on essaye de binder une liste avec liste infinie, ou avec une taille min inferieur a la max, et justement on transfere le min
                    et qu'il y a encore des arguments après
                    
                    SOLUTION 1
                        on s'arrete au prochain param token identifié
                            et s'il n'y en a pas ? jusqu'au bout du flux ou de la limite

                    SOLUTION 2 
                        on defini une taille après le param genre -toto:5
                            ça demande d'ajouter une info en + alors...
                                c'est chiant

    !!!! ne devrait rien changer au decorateur, ArgChecker et argFeeder !!!
        ils fournissent juste un outils de verification de l'argument, des valeurs par defaut et des noms
        le argFeeder se charge juste de faire le binding, les valeurs paramètrées doivent être retirée avant, on fait une couche suplémentaire par dessus
            devra se trouver juste après la recherche de commande
            et juste avant le argfeeder

### parameter files ###
    what to parameter:
        tab_length
        history file for raw input
        
    
### workflow ###
    #n'afficher dans l'aide et n'autoriser que les commandes executables

### application  ###
    #on remplace le leveltries courrant par un contenant uniquement les commandes de l'application
        #avec une commande exit pour restaurer le leveltries principale
        #les commandes du leveltries principales doivent toujours être accessible dans les commandes de l'application
        #les apps doivent pouvoir executer du code et en même temps appeler des commandes sur le shell
        
### service installer ###
    #être en mesure d'activer des applications en tant que service
        #au démarrage entre autre

### print service ###
	an interface with a few meth
		info
		error
		warn
		...
### code generator ###
    #génerer du code executable en dehors du shell
    
    #trois level de code executable:
        #level 0: un maximum de chose ont déjà été interprété (calcul d'apdu, de checksum, etc.)
            #il ne reste plus qu'à transmettre les données au framework
            
        #level 1: rien n'a encore été calculé (calcul d'apdu, ...)
            #on génére le code avec les appels de fonction encore parametrable
            #implique une dépendance au code calculant les apdus
            
        #level 2: rien n'est calculé, on execute via le shell
            #on est en niveau de script
            #besoin de l'ensemble du code
        

### context ###
    #element faisant partie du contexte
        #type de lecteur
        #version du firmware du lecteur
        #type de carte
        #version de la carte
        #type de framew

### rfid ###
    #adapter l'ensemble du code existant au nouveau shell

    #/System/Library/Frameworks/PCSC.framework/Versions/A/Headers/winscard.h
        le wrapper essaye de mapper une fonction qui n'existe pas dans la lib en C, on ne peut pas faire grand chose
   
   #faire un système de gestion des codes d'erreurs
	    à faire dans executeAPDU

   #faire un système de décapsulation des réponses
	    +- en place

   #manage error code
	    -pouvoir ajouter son propre handler d'erreur

### ... ###
